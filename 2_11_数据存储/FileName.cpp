#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//统一int类型4字节32bit
//原码：将数字编程二进制
//反码：符号位不变，其他按位取反
//补码：反码+1
//内存中存储的都是补码
//反码->源码可以-1按位取反 / 补码+1按位取反

//大端字节序存储：将一个数据的高位字节序内容放在低地址内存中
//小端字节序存储：将一个数据的低位字节序内容放在低地址内存中

//
//char a = -128;
//printf("%u\n", a);
//10000000000000000000000010000000	-128原码
//11111111111111111111111101111111	-128反码
//11111111111111111111111110000000	-128补码
//10000000							a为32位存入char发生截断
//									整型提升（看原来类型）先提升再用（后原反补）
//11111111111111111111111110000000	对10000000整型提升
//11111111111111111111111110000000	
//

//
//char a = 128;
//printf("%u\n", a);				先把a拿出来然后%u识别无符号打印
//00000000000000000000000010000000
//10000000
//11111111111111111111111110000000	整型提升（看原来类型）先提升再用（后原反补）
//^|
//10000000000000000000000001111111
//10000000000000000000000010000000
//

//
//10000000000000000000000000010100	内存中是补码
//11111111111111111111111111101011	正数不管但是负数一定要转成原码计算
//11111111111111111111111111101100
//+
//00000000000000000000000000001010
//=
//11111111111111111111111111110110
//
//10000000000000000000000000001001	原反补
//10000000000000000000000000001010
//

//
// unsigned int i;
// for(i = 9; i >= 0; i--)
// {
//		printf("%u\n", i);
//	}
//	return 0;
//00000000000000000000000000000000
//10000000000000000000000000000001	-1的原码
//11111111111111111111111111111111	补码（存进去的时候将原码换成补码）
//

//
// char a[1000];
// int i;
// for(i=0;i<1000;i++)
// {
//		a[i] = -1 - i;
//	}
// printf("%d", strlrn(a));
// return 0;
// 10000000000000000000000000000001
// 11111111111111111111111111111111		-1补码
// 11111111
// 
// 10000000000000000000000000000010
// 11111111111111111111111111111110		-2补码
// 11111110
// 
// -1 -2 -3 ....... -128 127 126 ...... 3 2 1 0
// 一共255个strlrn读到0就终止了
//

//
// unsigned char i = 0;
// int main()
// {
//		for(i = 0; i <= 255; i++)
//		{
//			printf("hello world\n");
//		}
//		return 0;
// }
// 
//

int main()
{
	//int a = 1;
	//if (*(char*)&a == 1)
	//	printf("小端\n");
	//else
	//	printf("大端\n");

	//int a = 1;
	//char* p = (char*)&a;
	//if (*p)
	//	printf("小端\n");
	//else
	//	printf("大端\n");

	float f = 5.5;
	//
	// 101.1
	// 1.011 * 2^2
	// S=0 M=1.011(存储011,末尾补0占满23) E=2	S(1) M(23) E(8)
	// 
	// E存储进去对其+中间值32(8)位是127，64(11)位是1023
	// 
	// 0 10000001 01100000000000000000000
	// 0100 0000 1011 0000 0000 0000 0000 0000
	// 4    0    b(11) 0   0    0    0    0
	// 0x40 b0 00 00	十六位存储
	//   00 00 b0 40	小端存储
	// 
	//			S				M				  E
	// 还原(-1)^0 * 1.01100000000000000000000 * 2^2
	//										2^(10000001->129-127=2)
	//


	return 0;

}